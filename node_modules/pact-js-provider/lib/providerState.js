'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _es6Promise = require('es6-promise');

var _rubyVerifier = require('./rubyVerifier');

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ProviderState = function () {
  function ProviderState(providerName, stateName, providerStateTests) {
    _classCallCheck(this, ProviderState);

    this.providerName = providerName;
    this.stateName = stateName;
    this.providerStateTests = providerStateTests;
  }

  _createClass(ProviderState, [{
    key: 'run',
    value: function run() {
      var _this = this;

      var _providerStateTests = this.providerStateTests;
      var setup = _providerStateTests.setup;
      var teardown = _providerStateTests.teardown;
      var options = _providerStateTests.options;

      this.options = options;

      return this._runStage(setup).then(function () {
        return _this._execute(_this.options);
      }).then(function () {
        return _this._runStage(teardown);
      }, function () {
        return _this._runStage(teardown);
      }).then(function (result) {
        return _es6Promise.Promise.resolve(result);
      }).catch(function (err) {
        _logger2.default.error(err.stack);
        return _es6Promise.Promise.reject(err);
      });
    }
  }, {
    key: '_runStage',
    value: function _runStage(method) {
      var _this2 = this;

      _logger2.default.debug('_runStage ');
      if (method != undefined) {
        return new _es6Promise.Promise(function (resolve, reject) {
          return method.apply(_this2, [resolve, reject]);
        });
      }
      return _es6Promise.Promise.reject(new Error('Method is undefined'));
    }
  }, {
    key: '_execute',
    value: function _execute(options) {
      return (0, _rubyVerifier.rakeVerify)(this.providerName, this.stateName, options);
    }
  }]);

  return ProviderState;
}();

exports.default = ProviderState;